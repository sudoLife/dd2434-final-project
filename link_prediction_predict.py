from __future__ import print_function, division

import pickle
import numpy as np
from sklearn import pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score
from sklearn.preprocessing import StandardScaler

from DeepWalk import DeepWalk
from link_prediction_split_graph import default_params

'''
README

Run link_prediction_split_graph.py before this

In the main() function:
1. Change the graph_name
2. Specify the embedding_method
3. Use the [graph_name]_graph.pkl generated by link_prediction_split_graph.py 
    to get the embeddings as a npy file, an example is provided.
4. Load the embeddings
5. Run it
'''

edge_functions = {
    "hadamard": lambda a, b: a * b,
    "average": lambda a, b: 0.5 * (a + b),
    "l1": lambda a, b: np.abs(a - b),
    "l2": lambda a, b: np.abs(a - b) ** 2,
    "normalized_inner_product": lambda a, b: 1 / (1 + np.exp(-np.dot(a, b)))  # the one used in the paper
}


def get_embeddings_of_train_graph(embedding_file_path):
    embeddings = np.load(embedding_file_path)
    return embeddings


def edges_to_features(edge_list, nodes_list, embeddings, edge_function, dimensions):
    """
    Use embedding vectors to calculate a (similarity) score for each pair (ordered)
    of nodes in the test set edge_list. This will be the input to the classifier.
    """
    n_tot = len(edge_list)
    feature_vec = np.empty((n_tot, dimensions), dtype='f')

    # Iterate over edges
    for ii in range(n_tot):
        v1, v2 = edge_list[ii]

        # Edge-node features
        emb1 = embeddings[nodes_list.index(v1)]
        emb2 = embeddings[nodes_list.index(v2)]

        # Calculate edge feature
        feature_vec[ii] = edge_function(emb1, emb2)

    return feature_vec


def link_prediction(edges_train, labels_train, edges_test, labels_test, emb, nodes_list, graph_name, emb_method):
    dimensions = emb.shape[1]
    auc_score = {name: [] for name in edge_functions}

    print("Link prediction starts.")

    for edge_fn_name, edge_fn in edge_functions.items():
        # Calculate edge embeddings using binary function
        edge_features_train = edges_to_features(edges_train, nodes_list, emb, edge_fn, dimensions)
        edge_features_test = edges_to_features(edges_test, nodes_list, emb, edge_fn, dimensions)

        # Linear classifier
        scalar = StandardScaler()
        lin_clf = LogisticRegression(C=1)
        clf = pipeline.make_pipeline(scalar, lin_clf)

        # Train classifier
        clf.fit(edge_features_train, labels_train)

        # Test classifier
        test_predict_proba = clf.predict_proba(edge_features_test)
        auc_test = roc_auc_score(labels_test, test_predict_proba[:, 1])
        auc_score[edge_fn_name].append(auc_test)

    print("====== AUC Scores ======")
    for edge_name in auc_score:
        auc_mean = np.mean(auc_score[edge_name])
        auc_std = np.std(auc_score[edge_name])
        print("[%s]: %.4g" % (edge_name, auc_mean))

    return auc_score


def main():
    # NOTE: Don't forget to change the graph name here everytime you use a new dataset
    graph_name = 'CollegeMsg'

    # Remember to change the embedding_method name
    embedding_method = "DeepWalk"

    # Just as an example, get embeddings of the training graph with DeepWalk and store the result into npy file
    train_graph_fn = "%s%s_graph.pkl" % ("LP_data/", graph_name)
    with open(train_graph_fn, 'rb') as fp:
        G_train = pickle.load(fp)

    nodes_list = list(G_train.nodes())

    print("Done loading G_train and nodes_list")
    #
    # deepwalk = DeepWalk(G_train, window=10, embedding_size=128,
    #                     walks_per_vertex=80, walk_length=40)
    # corpus = deepwalk.generate_corpus()
    # embedding_array = deepwalk.train(corpus, workers=1, epochs=1)
    embedding_fn = "embedding_result/LP_%s_%s.npy" % (embedding_method, graph_name)
    # np.save(embedding_fn, embedding_array)
    # print("Done with saving the embedding result of training graph")

    # TODO: load different embeddings results here
    embedding_file_path = embedding_fn
    emb = get_embeddings_of_train_graph(embedding_file_path)

    print(f"Link prediction of {graph_name} using {embedding_method}")
    for i, prop in enumerate(default_params['prop_reversed_neg']):
        print(f"AUC scores with prop_reversed_neg={prop}")
        edges_split_fn = "%s%s_edges_split_%s.pkl" % ("LP_data/", graph_name, prop)
        with open(edges_split_fn, 'rb') as fp:
            train_and_test_data = pickle.load(fp)

        edges_train, labels_train, edges_test, labels_test = train_and_test_data

        link_prediction(edges_train, labels_train, edges_test, labels_test, emb, nodes_list, graph_name,
                        embedding_method)

if __name__ == "__main__":
    main()
